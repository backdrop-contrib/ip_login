<?php
/**
 * Allow user login by IP Address
 * by David W Thomas
 * updated by Jim Kirkpatrick
 */

/* recently done:
 *    fixed a few incorrect usages of t()
 * 
 * @todo for security, IP addresses and ranges should really be checked for collisions between existing accounts users
 * @todo Check usage of $GLOBALS['conf']['cache'] in ip_login_attempt_login())
 * @todo Integrate with Content Profile
*/

define('ATTEMPT_IP_LOGIN', 'user/login_by_ip'); // path for ip login
define('IP_CHECKED', 'ip_login_checked'); // true when IP check has happened
define('IP_UID_MATCH', 'ip_login_uid'); // true when a user profile matches the request IP
define('LOGIN_BY_IP_COMPLETE', 'ip_login_by_ip_complete'); // true when IP login process has completed
define('LOGIN_AS_DIFFERENT_USER', 'ip_login_as_different_user'); // true when user wants alternate account


/**
 * Implementation of hook_boot().
 * 
 *   see http://drupal.org/node/509028
 */
function ip_login_boot() {
  // skip rest of this if the admin has disabled IP login
  if (!variable_get('ip_login_enabled', 1)) return;

  // get sanisised session variables
  $_SESSION[IP_CHECKED] = (isset($_SESSION[IP_CHECKED]) ? $_SESSION[IP_CHECKED] : FALSE);
  $_SESSION[LOGIN_AS_DIFFERENT_USER] = (isset($_SESSION[LOGIN_AS_DIFFERENT_USER]) ? $_SESSION[LOGIN_AS_DIFFERENT_USER] : FALSE);
  $_SESSION[LOGIN_BY_IP_COMPLETE] = (isset($_SESSION[LOGIN_BY_IP_COMPLETE]) ? $_SESSION[LOGIN_BY_IP_COMPLETE] : FALSE);

  // have we checked user IP?
  if (!$_SESSION[IP_CHECKED]) {
    ip_login_check(ip_address());
    // $_SESSION[IP_CHECKED] is now true, $_SESSION[IP_UID_MATCH] now contains uid matched or 0 if no match;
  }

  // get user and check make sure they want to be auto-logged in
  global $user; 
  if (!$_SESSION[LOGIN_BY_IP_COMPLETE] && $user->uid == 0 && !$_SESSION[LOGIN_AS_DIFFERENT_USER]) {
    // not ip logged in, or wanting another account
    if ($_SESSION[IP_UID_MATCH] > 0) {
      // we have a matching uid so log in
      ip_login_login($_SESSION[IP_UID_MATCH]);
    }
  }
}


/**
 * Implementation of hook_help().
 */
function ip_login_help($path, $arg) {
  // @todo use t()
  switch ($path) {
    case 'admin/settings/iplogin':
      $help =  '<p>';
      $help .= t("This module allows this site to automatically authenticate and login users arriving with a chosen IP address.") . ' ';
      $help .= t("IP values can be stored in a user's profile (using the core <em>Profile</em> module) in the field selected by the <em>Profile module IP address</em> field, below.") . ' ';
      $help .= t(
        'It also allows users with the <code>administer ip login</code> and <code>can log in as another user</code> <a href="@permissions-link">permissions</a> to log out and log in as another user, with other users being forced to stay logged in.',
        array('@permissions-link' => '/admin/user/permissions#module-ip_login'));
      $help .=  '</p><p>';
      $help .= t('Accepted profile field IP values are:');
      $help .= '</p><ul><li>';
      $help .= t("Single IP matches like <code>123.123.123.123</code>");
      $help .= '</li><li>';
      $help .= t("Wildcards using an asterisk (<code>*</code>) in any quadrant except the first one, for example <code>123.123.123.*</code> or <code>100.*.*.*</code> etc.");
      $help .= '</li><li>';
      $help .= t("Ranges using a hyphen (<code>-</code>) in any quadrant except the first one, for example <code>123.123.123.100-200</code> etc.");
      $help .= '</li><li>';
      $help .= t("Any number of comma-separated IP addresses or ranges like <code>10.11.12.13, 123.123.123.100-200, 123.123.124-125.*</code> etc.");
      $help .= '</li></ul>';
      return $help;
  }
}


/**
 * Implementation of hook_user().
 * 
 * Allows users to log out without immediately logging them back in.
 * NOTE: this module may stop other modules hook_user(logout) code firing as it
 * destroys the session
 */
function ip_login_user($op, &$edit, &$account, $category = NULL) {
  // if logging out and we're currently logged in by IP...
  if ($op == "logout" && $_SESSION[IP_UID_MATCH] >0) ip_login_as_different_user();
}


/**
 * Implementation of hook_menu().
 */
function ip_login_menu() {
  $items[ATTEMPT_IP_LOGIN] = array(
    'title' => 'Automatically log me in by IP',
    'access callback' => 'ip_login_is_possible',
    'page callback' => 'ip_login_attempt_login',
    'type' => MENU_CALLBACK,
  );
  $items['admin/settings/iplogin'] = array(
    'title' => 'IP Login settings',
    'description' => 'Configure IP Login settings',
    'access callback' => 'user_access',
    'access arguments' => array('administer ip login'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ip_login_admin_settings'),
    'file' => 'ip_login.admin.inc',
    'type' => MENU_NORMAL_ITEM,
    );
  return $items;
}


/**
 * Returns TRUE if login by IP can happen
 * 
 * Used for menu access
 */
function ip_login_is_possible() {
  return ($_SESSION[IP_UID_MATCH] > 0);
}


/**
 * Checks the request IP and logs user in there's a match by calling
 * ip_login_check then ip_login_attempt_login
 */
function ip_login_attempt_login() {
  $GLOBALS['conf']['cache'] = false; // don't cache - not sure if this is correct usage
  $uid_matched = ip_login_check(ip_address());
  if ($uid_matched) ip_login_login($uid_matched);
  drupal_goto(variable_get('ip_login_destination', 'user'));
}


/**
 * Implementation of hook_perm().
 */
function ip_login_perm() {
  // @todo add perms checks to correct places in module
  return array('administer ip login', 'can log in as another user');
}

/**
 * Implementation of hook_form_alter().
 */
function ip_login_form_alter(&$form, &$form_state, $form_id) {
  if (!ip_login_is_possible()) return;
  
  if ($form_id == 'user_login') {
    $link_text = t(variable_get('ip_login_link_login_page', 'Log in automatically'));
    if (strlen($link_text)) { // hide if no link text
      $link_help = t(variable_get('ip_login_link_login_page_help', "Your computer's IP address has been matched and validated."));
      $markup .= '<br/>';
      $markup .= '<ul class="item-list">';
      $markup .= '<li><strong>' . l($link_text, ATTEMPT_IP_LOGIN) . '</strong>';
      if (strlen($link_help)) $markup .= '<br/><small>' . filter_xss_admin($link_help) . '</small>';
      $markup .= '</li></ul>';
      $form['ip_login'] = array(
        '#value' => $markup,
        '#weight' => variable_get('ip_login_link_login_page_weight', -10),
      );
    }
  }
  elseif ($form_id == 'user_login_block') {
    $link_text = t(variable_get('ip_login_link_login_block', 'Log in automatically'));
    if (strlen($link_text)) { // hide if no link text
      $markup .= '<ul class="item-list">';
      $markup .= '<li><strong>' . l($link_text, ATTEMPT_IP_LOGIN) . '</strong>';
      $markup .= '</li></ul>';
      $form['ip_login'] = array(
        '#value' => $markup,
        '#weight' => variable_get('ip_login_link_login_block_weight', -10),
      );
    }
  }
}


/**
 * Compares the current request's IP address to the user profile IP range field
 * and then does a proper match for each match on exact, ranges and wildcards
 * @param $ip
 *    An ip address string, usually from the current user's request
 * @return $uid_matched
 *    The uid of the matching user account
 */
function ip_login_check($ip, $diagnostics = FALSE) {
  // break up IP, get profile field for ip address
  $addr = explode(".", check_plain($ip));
  $profile_field = variable_get('ip_login_profile_ip_field', 'profile_ip');
  $matches = FALSE;

  // Find user profile ip values that matches the first part of the user's IP
  // ANYWHERE except the end - not desparetly efficient but works consistently
  // with comma separated IP ranges and spaces in the profile field.
  $partial_matches = db_query("SELECT pv.uid, pv.value FROM {profile_values} pv
             INNER JOIN {profile_fields} pf ON pv.fid = pf.fid
             WHERE pf.name = '%s' AND (pv.value) LIKE ('%s')", $profile_field, '%' . $addr[0] . '.%');

  $uid_matched = 0;
  while (($partial_match = db_fetch_object($partial_matches)) && !$uid_matched) {

    // multiple values are separated with commas so try each in turn
    $profile_ip_ranges = explode(",", $partial_match->value);
    foreach ($profile_ip_ranges as $ip_range) {

      // clear any whitespace, break into quads, then compare
      $ip_range = explode('.', trim($ip_range));
      foreach ($ip_range as $index => $quad) {
        $matches = ip_login_match_quad($addr[$index], $quad);
        if (!$matches) break; // no match, escape this foreach and move on to next IP range
      }
      // if it matches, stop here and do login
      if ($matches) {
        $uid_matched = $partial_match->uid;
        break 2; // escape the foreach and while
      }
    }
  }
  
  // if not diagnostic test, set processed session flag, store matching user (if there is one)
  if (!$diagnostics) {
    $_SESSION[IP_CHECKED] = TRUE;
    $_SESSION[IP_UID_MATCH] = $uid_matched;
  }
  return $uid_matched;
}

/**
 * Log user with $uid in ip address and profile_ip profile field
 * 
 * @param $ip
 *    An ip address string
 */
function ip_login_login($uid) {
  if ($uid) { // if a uid is passed in
    // get user module and include some handy functions
    drupal_bootstrap(DRUPAL_BOOTSTRAP_FULL);

    if ($account = user_load(array('uid' => $uid, 'status' => 1))) { // if loaded active user
      // login by assigning account to global $user object
      global $user;
      $user = $account;

      // notify user - if messages not suppressed
      if (!variable_get('ip_login_suppress_messages', 0)) {
        $message = t(
          'Welcome %name. You have been automatically logged into %sitename.',
          array(
            '%name' => $user->name,
            '%sitename' => variable_get('site_name', 'this website'),
          ));
        drupal_set_message($message);

        // add handy message for those who can log out and then back in as another user
        if (_ip_login_can_use_alternate_account($user)) {
          $message = t(
            'You may also <a href="@other_user_link">log in as another user</a> if required.',
            array('@other_user_link' => url('logout'))
          );
          drupal_set_message($message);
        }
      }
      watchdog('user', 'Session opened for %name by IP Login.', array('%name' => $user->name));
      $_SESSION[LOGIN_BY_IP_COMPLETE] = TRUE;
      $_SESSION[LOGIN_AS_DIFFERENT_USER] = FALSE;
      
      // Update the user table timestamp noting user has logged in.
      db_query("UPDATE {users} SET login = %d WHERE uid = %d", time(), $user->uid);
      // IMPORTANT: drupal call to regenerate session data for anon user to authenticated user
      sess_regenerate();

      // invoke hook_user in other modules
      $null = NULL;
      user_module_invoke('login', $null, $user);


      // following borrowed from ipAuthenticator's login and avoids caching issues
      if (variable_get('cache', CACHE_DISABLED) != CACHE_DISABLED && !isset($_GET['ip_login_no_cache'])) {
        // make a url to reload page, remove newlines from the URL to avoid header injection attacks.
        // use admin settings for destination if set.
        $url = variable_get('ip_login_destination', '');
        if (strlen($url) == 0) $url = str_replace(array("\n", "\r"), '', $_GET["q"]);
        if ($url == 'logout') $url = '<front>';
        $url = url($url, array('query' => 'ip_login_no_cache='.md5(time()), 'absolute' => TRUE));
        // Before the redirect, allow modules to react to the end of the page request.
        module_invoke_all('exit', $url);

        // Even though session_write_close() is registered as a shutdown function, we
        // need all session data written to the database before redirecting.
        session_write_close();

        header('Location: '. $url, TRUE, 302);
        exit();
      }
    }
  }
}


/**
 * Logs the current user out.
 * 
 * Called from hook_user on logout, most of the code taken from user_logout()
 * and _drupal_bootstrap().
 */
function ip_login_as_different_user() {

  global $user;
  watchdog('user', 'Session closed for %name.', array('%name' => $user->name));

  // store whether this user can log back in automatically
  $can_login_as_another_user = _ip_login_can_use_alternate_account($user);

  // Destroy the current session, if we have one; wipe the IP Login UID to ensure no loops on call to hook_user(logout)
  if (session_name() <> '') session_destroy();
  $_SESSION[IP_UID_MATCH] = 0; 

  // Call other module's hook_user logout functions
  $null = NULL; //Only variables can be passed by reference workaround.
  user_module_invoke('logout', $null, $user);

  // Load the anonymous user
  $user = drupal_anonymous_user();

  require_once variable_get('session_inc', './includes/session.inc');
  session_set_save_handler('sess_open', 'sess_close', 'sess_read', 'sess_write', 'sess_destroy_sid', 'sess_gc');
  session_start();

  $_SESSION[LOGIN_AS_DIFFERENT_USER] = $can_login_as_another_user;
  $_SESSION[LOGIN_BY_IP_COMPLETE] = FALSE;

  if (!$_SESSION[LOGIN_AS_DIFFERENT_USER]) {
    $message = t('This account does not have permission to log out once logged in automatically. You have been logged back in.');
    drupal_set_message($message, 'warning');
  }
  // show the login page
  drupal_goto(variable_get('ip_login_destination', 'user'));
}


/**
 * Compares a single IP quadrant to a matching quadrant
 *
 * The matching quad can contain wildcards (*), ranges (10-12) or exact numbers
 * @param $find_value
 *    A string containing the quadrant value being looked for
 * @param $in_range
 *    String with a quadrant value, range or wildcard to compare to
 * @return TRUE
 *    If $find_value matches an IP address $in_range
 *
 */
function ip_login_match_quad($find_value, $in_range) {
  // if we've got a wildcard just return TRUE
  if ($in_range == '*') return TRUE; 

  // check if this quad contains the range character '-'
  $range = explode('-', $in_range);
  if (isset($range[1])) {
    // we've got a range, test upper and lower bounds
    if (($find_value >= $range[0]) && ($find_value <= $range[1])) return TRUE;
  }
  else {
    // no range, just do normal match
    return ($range[0] == $find_value);
  }
  return FALSE;
}

/*
 * Returns TRUE if a user has permission to log out and back in as another user
 */
function _ip_login_can_use_alternate_account($user) {
  return false;
  // only allow users with correct permission to log in as another user,
  // this presently enforced by an immediate re-login by IP
  if ($user->uid == 1) return TRUE; // super user can
  // people who can administer this module can
  if (user_access('administer ip login', $user)) return TRUE;
  // people running from their own machines can
  //if (ip_address() == '127.0.0.1') return TRUE;

  // If the user doesn't have a matching IP, then we let them log in normally
  if (!ip_login_check(ip_address()))
    return true;

  // all others check correct permission
  return user_access('can log in as another user', $user);
}



/*
 * Implementation of hook_uninstall
 */
function hook_uninstall() {
  variable_del('ip_login_enabled');
  variable_del('ip_login_destination');
  variable_del('ip_login_profile_ip_field');
  variable_del('ip_login_link_login_block_weight');
  variable_del('ip_login_link_login_block');
  variable_del('ip_login_link_login_page_weight');
  variable_del('ip_login_link_login_page_help');
  variable_del('ip_login_link_login_page');
  variable_del('ip_login_suppress_messages');
}
